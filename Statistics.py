import numpy as np
from abcpy.statistics import Statistics

class HakkarainenLorenzStatistics(Statistics):
    """
    This class implements the statistics function from the Statistics protocol. This 
    extracts the statistics following Hakkarainen et. al. [1] from the multivariate timesereis 
    generated by solving Lorenz 95 odes.
    
    [1] J. Hakkarainen, A. Ilin, A. Solonen, M. Laine, H. Haario, J. Tamminen, E. Oja, and 
    H. Järvinen. On closure parameter estimation in chaotic systems. Nonlinear Processes 
    in Geophysics, 19(1):127–143, Feb. 2012.
    """

    def __init__(self, degree=2, cross=True):
        self.degree = degree
        self.cross = cross
        
    def statistics(self, data):      
        if isinstance(data, list):
            if np.array(data).shape == (len(data),):
                if len(data) == 1:
                    data = np.array(data).reshape(1, 1)
                data = np.array(data).reshape(len(data), 1)
            else:
                data = np.concatenate(data).reshape(len(data), -1)
        else:
            raise TypeError('Input data should be of type list, but found type {}'.format(type(data)))
        ## Extract Hakkarainen Summary Statistics
        num_element, timestep = len(data), int(data[0].shape[0]/40)
        result = np.zeros(shape=(num_element,6))
        # Compute statistics
        for ind_element in range(0,num_element):
            # First convert the vector to the 40 dimensional timeseries
            data_ind_element = data[ind_element].reshape(40,timestep)
            # Extract Mean
            s1 = np.mean(np.mean(data_ind_element,1))
            # Variance
            s2 = np.mean(np.var(data_ind_element,1))
            ## Extract Auto Covariance with lag 1
            s3 = 0.0
            for ind in range(0,data_ind_element.shape[0]):
                s3 += self._auto_covariance(data_ind_element[ind,:], lag = 1) 
            s3 = s3/data_ind_element.shape[0]
            ## Extract Covariance with a neighboring node
            s4 = 0.0
            for ind in range(0,data_ind_element.shape[0]-1):            
                s4 += np.mean(data_ind_element[ind,:]*data_ind_element[ind+1,:])\
                    - np.mean(data_ind_element[ind,:])*np.mean(data_ind_element[ind+1,:])
            s4 = s4/data_ind_element.shape[0]
            ## Extract Cross-Cov with 2 neighbors with time lag 1
            s5 = 0.0
            s6 = self._cross_covariance(data_ind_element[1,:],data_ind_element[2,:])
            for ind in range(1,data_ind_element.shape[0]-1):
                s5 += self._cross_covariance(data_ind_element[ind,:],data_ind_element[ind-1,:])
                s6 += self._cross_covariance(data_ind_element[ind,:],data_ind_element[ind+1,:])
            s5 += 0.0
            s6 += self._cross_covariance(data_ind_element[-2,:],data_ind_element[-1,:])
            s5 = s5/data_ind_element.shape[0]
            s6 = s6/data_ind_element.shape[0]
            
            result[ind_element,:] = [s1, s2, s3, s4, s5, s6] 
            
        # Expand the data with polynomial expansion            
        result = self._polynomial_expansion(result)
        return np.array(result)
    
    def _cross_covariance(self, x, y):
        """ Computes cross-covariance between x and y 
        
        Parameters
        ----------
        x: numpy.ndarray
            Vector of real numbers.
        y: numpy.ndarray
            Vector of real numbers.
        
        Returns
        -------
        numpy.ndarray
            Cross-covariance calculated between x and y.
        """
        return np.mean(np.insert(x,0,1)*np.insert(y,-1,1))-np.mean(np.insert(x,0,1))*np.mean(np.insert(y,-1,1))

    def _auto_covariance(self, x, lag = 1):
        """
        Calculate the autocovarriance coefficient of x with lag k.

        Parameters
        ----------
        x: numpy.ndarray
            Vector of real numbers.
        k: integer
            Time-lag.
        
        Returns
        -------
        numpy.ndarray
            Returns the auto-covariance of x with time-lag k.
        """

        N = x.shape[0]
        x_mean = np.average(x)

        autoCov = 0.0
        for ind in range(0, N-lag):
            autoCov += (x[ind+lag]-x_mean)*(x[ind]-x_mean)
        return (1/(N-1))*autoCov